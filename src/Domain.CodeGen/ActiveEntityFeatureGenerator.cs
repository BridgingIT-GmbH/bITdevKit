// MIT-License
// Copyright BridgingIT GmbH - All Rights Reserved
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file at https://github.com/bridgingit/bitdevkit/license
namespace BridgingIT.DevKit.Domain;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
#pragma warning disable RS1036 // Specify analyzer banned API enforcement setting
#pragma warning disable RS1042 // Implementations of this interface are not allowed
#pragma warning disable RS1038 // Compiler extensions should be implemented in assemblies with compiler-provided references
[Generator]
public class ActiveEntityFeatureGenerator : IIncrementalGenerator
{
    private readonly List<IActiveEntityFeature> featuress =
    [
        new ForwarderFeature(),
        new ConventionFinderFeature(),
        new SpecificationFeature(),
        new QueryDslFeature()
    ];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Collect candidate classes with attributes
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(cds => cds is not null);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Register source output
        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
        {
            var (compilation, classes) = source;

            //spc.ReportDiagnostic(Diagnostic.Create("ARCG000", "Generator Info", $"ActiveEntityFeatureGenerator running. Found {classes.Length} candidate classes with attributes.", DiagnosticSeverity.Warning, DiagnosticSeverity.Warning, true, 4));

            var valueObjectSymbol = compilation.GetTypeByMetadataName("BridgingIT.DevKit.Domain.Model.ValueObject");
            var enumerationSymbol = compilation.GetTypeByMetadataName("BridgingIT.DevKit.Common.Enumeration");
            var featureContext = new FeatureGenerationContext(valueObjectSymbol, enumerationSymbol);

            foreach (var classDecl in classes)
            {
                var model = compilation.GetSemanticModel(classDecl.SyntaxTree);
                if (model.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
                {
                    continue;
                }

                var attr = classSymbol.GetAttributes() // Check for [ActiveEntityFeatures]
                    .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "BridgingIT.DevKit.Domain.ActiveEntityFeaturesAttribute");

                if (attr == null)
                {
                    continue;
                }

                //spc.ReportDiagnostic(Diagnostic.Create("ARCG001", "Generator Info", $" -> Class '{classSymbol.Name}' HAS the [ActiveEntityFeatures] attribute. Processing...", DiagnosticSeverity.Warning, DiagnosticSeverity.Warning, true, 4));

                var enabledFeatures = ActiveEntityFeatures.All;
                if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is int enumValue)
                {
                    enabledFeatures = (ActiveEntityFeatures)enumValue;
                }

                foreach (var feature in this.featuress)
                {
                    feature.Generate(spc, compilation, classSymbol, enabledFeatures, featureContext);
                }
            }
        });
    }
}

public class ForwarderFeature : IActiveEntityFeature
{
    public ActiveEntityFeatures Features => ActiveEntityFeatures.Forwarders;

    public void Generate(SourceProductionContext context, Compilation compilation, INamedTypeSymbol entityType, ActiveEntityFeatures enabledFeatures, FeatureGenerationContext featureContext)
    {
        if (!enabledFeatures.HasFlag(this.Features))
        {
            return;
        }

        var methods = FindExtensionMethods(compilation, entityType);
        if (!methods.Any())
        {
            return;
        }

        var ns = entityType.ContainingNamespace.ToDisplayString();
        var entityName = entityType.Name;

        var sb = new StringBuilder($@"
// <auto-generated />
// source: ActiveEntityFeatureGenerator: ForwarderFeature
namespace {ns}
{{
    public partial class {entityName}
    {{
");

        foreach (var method in methods)
        {
            var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var methodName = method.Name;

            var parameters = string.Join(", ",
                method.Parameters.Skip(1).Select(p =>
                    $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.Name}"));

            var args = string.Join(", ", method.Parameters.Skip(1).Select(p => p.Name));
            var firstParamType = method.Parameters[0].Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Forward XML docs
            var xmlDocs = method.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: default);
            if (!string.IsNullOrWhiteSpace(xmlDocs))
            {
                var indentedDocs = string.Join("\n        ",
                    xmlDocs.Split('\n').Select(l => l.TrimEnd()));
                sb.AppendLine("        /// <inheritdoc/>");
                sb.AppendLine($"        {indentedDocs}");
            }

            sb.AppendLine($@"
        public static {returnType} {methodName}({parameters}) =>
            (null as {firstParamType}).{methodName}({args});
");
        }

        sb.AppendLine("    }\n}");

        context.AddSource($"{entityName}.ActiveEntityForwarders.g.cs", sb.ToString());
    }

    private static IEnumerable<IMethodSymbol> FindExtensionMethods(Compilation compilation, INamedTypeSymbol entityType)
    {
        var results = new List<IMethodSymbol>();

        foreach (var tree in compilation.SyntaxTrees)
        {
            var model = compilation.GetSemanticModel(tree);
            var methods = tree.GetRoot()
                .DescendantNodes()
                .OfType<MethodDeclarationSyntax>();

            foreach (var m in methods)
            {
                if (model.GetDeclaredSymbol(m) is not IMethodSymbol methodSymbol)
                {
                    continue;
                }

                if (!methodSymbol.IsExtensionMethod)
                {
                    continue;
                }

                var firstParam = methodSymbol.Parameters.FirstOrDefault();
                if (firstParam?.Type is not INamedTypeSymbol nts)
                {
                    continue;
                }

                if (nts.OriginalDefinition.ToDisplayString().Contains("ActiveEntity") &&
                    SymbolEqualityComparer.Default.Equals(nts.TypeArguments.FirstOrDefault(), entityType))
                {
                    results.Add(methodSymbol);
                }
            }
        }

        return results;
    }
}

/// <summary>
/// Generates convention-based finder methods for each supported property of the entity.
/// Example: For a property "string FirstName", it generates:
///   public static Task<Result<IEnumerable<TEntity>>> FindAllByFirstNameAsync(string value, ...)
///   public static Task<Result<TEntity>> FindOneByFirstNameAsync(string value, ...)
/// </summary>
/// <summary>
/// Generates convention-based finder methods for each supported property of the entity.
/// Example: For a property "string FirstName", it generates:
///   public static Task&lt;Result&lt;IEnumerable&lt;TEntity&gt;&gt;&gt; FindAllByFirstNameAsync(string value, ...)
///   public static Task&lt;Result&lt;TEntity&gt;&gt; FindOneByFirstNameAsync(string value, ...)
/// </summary>
public class ConventionFinderFeature : IActiveEntityFeature
{
    public ActiveEntityFeatures Features => ActiveEntityFeatures.ConventionFinders;

    public void Generate(SourceProductionContext context, Compilation compilation, INamedTypeSymbol entityType, ActiveEntityFeatures enabledFeatures, FeatureGenerationContext featureContext)
    {
        if (!enabledFeatures.HasFlag(this.Features))
        {
            return;
        }

        var ns = entityType.ContainingNamespace.ToDisplayString();
        var entityName = entityType.Name;
        var tIdType = GetTIdType(entityType); // Helper to get TId type

        var sb = new StringBuilder($@"
// <auto-generated />
// source: ActiveEntityFeatureGenerator: ConventionFinderFeature
namespace {ns}
{{
    using BridgingIT.DevKit.Domain;
    using BridgingIT.DevKit.Domain.Repositories;
    using System.Collections.Generic;
    using System.Threading; // Added for CancellationToken
    using System.Threading.Tasks; // Added for Task

    public partial class {entityName}
    {{
");

        foreach (var prop in entityType.GetMembers().OfType<IPropertySymbol>())
        {
            if (!this.IsSupportedPropertyType(prop, featureContext))
            {
                continue;
            }

            var propName = prop.Name;
            var underlyingType = this.GetUnderlyingType(prop.Type);
            var parameterTypeName = underlyingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // --- FindAllBy{PropName}Async Overloads ---
            sb.AppendLine($@"
        /// <summary>
        /// Finds all {entityName} entities where {propName} equals the given value.
        /// </summary>
        public static Task<Result<IEnumerable<{entityName}>>> FindAllBy{propName}Async({parameterTypeName} value, FindOptions<{entityName}> options = null, CancellationToken ct = default) =>
            FindAllBy{propName}Async(context: null, value, options, ct); // Calls context-aware overload with null context
");

            sb.AppendLine($@"
        /// <summary>
        /// Finds all {entityName} entities where {propName} equals the given value using the specified context.
        /// </summary>
        public static Task<Result<IEnumerable<{entityName}>>> FindAllBy{propName}Async(global::BridgingIT.DevKit.Domain.ActiveEntityContext<{entityName}, {tIdType}> context, {parameterTypeName} value, FindOptions<{entityName}> options = null, CancellationToken ct = default) =>
            FindAllAsync(context, new global::BridgingIT.DevKit.Domain.Specification<{entityName}>(e => e.{propName} == value), options, ct);
");

            // --- FindOneBy{PropName}Async Overloads ---
            sb.AppendLine($@"
        /// <summary>
        /// Finds a single {entityName} entity where {propName} equals the given value.
        /// </summary>
        public static Task<Result<{entityName}>> FindOneBy{propName}Async({parameterTypeName} value, FindOptions<{entityName}> options = null, CancellationToken ct = default) =>
            FindOneBy{propName}Async(context: null, value, options, ct); // Calls context-aware overload with null context
");

            sb.AppendLine($@"
        /// <summary>
        /// Finds a single {entityName} entity where {propName} equals the given value using the specified context.
        /// </summary>
        public static Task<Result<{entityName}>> FindOneBy{propName}Async(global::BridgingIT.DevKit.Domain.ActiveEntityContext<{entityName}, {tIdType}> context, {parameterTypeName} value, FindOptions<{entityName}> options = null, CancellationToken ct = default) =>
            FindOneAsync(context, new global::BridgingIT.DevKit.Domain.Specification<{entityName}>(e => e.{propName} == value), options, ct);
");
        }

        sb.AppendLine("    }\n}");
        context.AddSource($"{entityName}.ActiveEntityConventionFinders.g.cs", sb.ToString());
    }

    private bool IsSupportedPropertyType(IPropertySymbol propertySymbol, FeatureGenerationContext featureContext)
    {
        if (propertySymbol.IsStatic || propertySymbol.IsIndexer)
        {
            return false;
        }

        var type = this.GetUnderlyingType(propertySymbol.Type);

        // Check for explicitly supported scalar-like types first.
        if (this.IsPrimitiveOrKnownStruct(type)
            || this.InheritsFrom(type, featureContext.ValueObjectSymbol)
            || this.InheritsFrom(type, featureContext.EnumerationSymbol))
        {
            return true;
        }

        // If it's not a supported scalar, then check if it's a collection and exclude it.
        if (type.AllInterfaces.Any(i => i.OriginalDefinition.ToDisplayString() == "System.Collections.IEnumerable"))
        {
            return false;
        }

        return false;
    }

    private bool IsPrimitiveOrKnownStruct(ITypeSymbol type)
    {
        return true; // Temporarily allow all types for testing purposes
        //var typeName = type.ToDisplayString();
        //return type.SpecialType switch
        //{
        //    SpecialType.System_Boolean => true,
        //    SpecialType.System_String => true,
        //    SpecialType.System_Int32 => true,
        //    SpecialType.System_Int64 => true,
        //    SpecialType.System_Double => true,
        //    SpecialType.System_Single => true,
        //    SpecialType.System_Decimal => true,
        //    SpecialType.System_DateTime => true,
        //    _ => typeName == "System.Guid" ||
        //         typeName == "System.DateTimeOffset" ||
        //         typeName == "System.DateOnly" ||
        //         typeName == "System.TimeOnly"
        //};
    }

    private bool InheritsFrom(ITypeSymbol type, INamedTypeSymbol baseTypeSymbol)
    {
        if (baseTypeSymbol == null)
        {
            return false;
        }

        var current = type;
        while (current != null)
        {
            // Primary, most reliable check using SymbolEqualityComparer
            if (SymbolEqualityComparer.Default.Equals(current, baseTypeSymbol))
            {
                return true;
            }

            // Fallback for cross-assembly issues where symbols might not be identical but names are.
            if (current.ToDisplayString() == baseTypeSymbol.ToDisplayString())
            {
                return true;
            }

            current = current.BaseType;
        }
        return false;
    }

    private ITypeSymbol GetUnderlyingType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol named && named.IsGenericType && named.OriginalDefinition.ToDisplayString() == "System.Nullable<T>" && named.TypeArguments.Length == 1)
        {
            return named.TypeArguments[0];
        }
        return type;
    }

    // Helper to extract TId type from ActiveEntity<TEntity, TId>
    private static string GetTIdType(INamedTypeSymbol entityType)
    {
        var baseType = entityType.BaseType;
        while (baseType != null && (!baseType.IsGenericType || baseType.OriginalDefinition.ToDisplayString() != "BridgingIT.DevKit.Domain.ActiveEntity<TEntity, TId>"))
        {
            baseType = baseType.BaseType;
        }

        if (baseType != null && baseType.IsGenericType && baseType.TypeArguments.Length == 2)
        {
            return baseType.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        // Fallback or error, depending on how strict you want to be.
        // If TId is truly always the second type argument of ActiveEntity, this should always succeed.
        return "System.Guid";
    }
}

/// <summary>
/// Generates a static Specifications class for the entity.
/// Example:
///   public static class Specifications {
///       public static Specification<Customer> IsActiveEquals(bool value) => new(c => c.IsActive == value);
///   }
/// </summary>
public class SpecificationFeature : IActiveEntityFeature
{
    public ActiveEntityFeatures Features => ActiveEntityFeatures.Specifications;

    public void Generate(SourceProductionContext context, Compilation compilation, INamedTypeSymbol entityType, ActiveEntityFeatures enabledFeatures, FeatureGenerationContext featureContext)
    {
        if (!enabledFeatures.HasFlag(this.Features))
        {
            return;
        }

        var ns = entityType.ContainingNamespace.ToDisplayString();
        var entityName = entityType.Name;

        var sb = new StringBuilder($@"
// <auto-generated />
// source: ActiveEntityFeatureGenerator: SpecificationFeature
namespace {ns}
{{
    public partial class {entityName}
    {{
        /// <summary>
        /// Provides reusable specifications for querying {entityName}.
        /// </summary>
        public static class Specifications
        {{
");

        foreach (var prop in entityType.GetMembers().OfType<IPropertySymbol>())
        {
            if (prop.IsStatic)
            {
                continue;
            }

            var propName = prop.Name;
            var underlyingType = this.GetUnderlyingType(prop.Type);
            var propTypeName = underlyingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isNullable = prop.NullableAnnotation == NullableAnnotation.Annotated || prop.Type.IsReferenceType;

            // Equals / NotEquals
            sb.AppendLine($@"
            /// <summary>
            /// Specification for {propName} equals the given value.
            /// </summary>
            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}Equals({propTypeName} value) =>
                new(e => e.{propName} == value);

            /// <summary>
            /// Specification for {propName} not equals the given value.
            /// </summary>
            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}NotEquals({propTypeName} value) =>
                new(e => e.{propName} != value);
");

            // IsNull / IsNotNull
            if (isNullable)
            {
                sb.AppendLine($@"
            /// <summary>
            /// Specification for {propName} is null.
            /// </summary>
            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}IsNull =>
                new(e => e.{propName} == null);

            /// <summary>
            /// Specification for {propName} is not null.
            /// </summary>
            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}IsNotNull =>
                new(e => e.{propName} != null);
");
            }

            // String-specific
            if (underlyingType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($@"
            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}IsEmpty =>
                new(e => string.IsNullOrEmpty(e.{propName}));

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}IsNotEmpty =>
                new(e => !string.IsNullOrEmpty(e.{propName}));

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}Contains(string value) =>
                new(e => e.{propName} != null && e.{propName}.Contains(value));

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}DoesNotContain(string value) =>
                new(e => e.{propName} == null || !e.{propName}.Contains(value));

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}StartsWith(string value) =>
                new(e => e.{propName} != null && e.{propName}.StartsWith(value));

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}DoesNotStartWith(string value) =>
                new(e => e.{propName} == null || !e.{propName}.StartsWith(value));

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}EndsWith(string value) =>
                new(e => e.{propName} != null && e.{propName}.EndsWith(value));

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}DoesNotEndWith(string value) =>
                new(e => e.{propName} == null || !e.{propName}.EndsWith(value));
");
            }

            // Fully comparable types (numeric, temporal)
            if (this.IsFullyComparable(underlyingType))
            {
                sb.AppendLine($@"
            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}GreaterThan({propTypeName} value) =>
                new(e => e.{propName} > value);

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}GreaterThanOrEquals({propTypeName} value) =>
                new(e => e.{propName} >= value);

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}LessThan({propTypeName} value) =>
                new(e => e.{propName} < value);

            public static global::BridgingIT.DevKit.Domain.Specification<{entityName}> {propName}LessThanOrEquals({propTypeName} value) =>
                new(e => e.{propName} <= value);
");
            }
        }

        sb.AppendLine("        }\n    }\n}");

        context.AddSource($"{entityName}.ActiveEntitySpecifications.g.cs", sb.ToString());
    }

    private ITypeSymbol GetUnderlyingType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol named && named.IsGenericType && named.Name == "Nullable" && named.TypeArguments.Length == 1)
        {
            return named.TypeArguments[0];
        }
        return type;
    }

    private bool IsFullyComparable(ITypeSymbol type)
    {
        var typeName = type.ToDisplayString();

        return type.SpecialType == SpecialType.System_Int32 ||
               type.SpecialType == SpecialType.System_Int64 ||
               type.SpecialType == SpecialType.System_Double ||
               type.SpecialType == SpecialType.System_Single ||
               type.SpecialType == SpecialType.System_Decimal ||
               type.SpecialType == SpecialType.System_DateTime ||
               typeName == "System.DateTimeOffset" ||
               typeName == "System.DateOnly" ||
               typeName == "System.TimeOnly";
    }
}

/// <summary>
/// Generates a fluent Query DSL for ActiveEntity entities.
/// Example:
/// var customers = await Customer.Query()
///     .Where(c => c.LastName == "Doe")
///     .OrderBy(c => c.FirstName)
///     .Include(c => c.Orders)
///     .ToPagedListAsync();
/// </summary>
public class QueryDslFeature : IActiveEntityFeature
{
    public ActiveEntityFeatures Features => ActiveEntityFeatures.QueryDsl;

    public void Generate(SourceProductionContext context, Compilation compilation, INamedTypeSymbol entityType, ActiveEntityFeatures enabledFeatures, FeatureGenerationContext featureContext)
    {
        if (!enabledFeatures.HasFlag(this.Features))
        {
            return;
        }

        var ns = entityType.ContainingNamespace.ToDisplayString();
        var entityName = entityType.Name;

        // Extract the actual TId type from the base class (e.g., CustomerId or Guid)
        var baseType = entityType.BaseType;
        var tIdType = "System.Guid"; // Default fallback
        if (baseType != null && baseType.IsGenericType && baseType.TypeArguments.Length == 2)
        {
            tIdType = baseType.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        var sb = new StringBuilder($@"
// <auto-generated />
// source: ActiveEntityFeatureGenerator: QueryDslFeature
namespace {ns}
{{
    using BridgingIT.DevKit.Domain;
    using BridgingIT.DevKit.Domain.Repositories;
    using System;
    using System.Collections.Generic;
    using System.Linq.Expressions;
    using System.Threading.Tasks;

    public partial class {entityName}
    {{
        /// <summary>
        /// Starts a fluent query for {entityName}.
        /// </summary>
        /// <example>
        /// var customers = await {entityName}.Query()
        ///     .Where(c => c.LastName == ""Doe"")
        ///     .OrderBy(c => c.FirstName)
        ///     .Include(c => c.Orders).ToPagedListAsync();
        /// </example>
        public static {entityName}Query Query() => new {entityName}Query();

        /// <summary>
        /// Provides a fluent DSL for querying {entityName}.
        /// </summary>
        public class {entityName}Query : ActiveEntityQueryBase<{entityName}, {tIdType}>
        {{
            protected override Task<Result<IEnumerable<{entityName}>>> FindAllInternal(
                IEnumerable<ISpecification<{entityName}>> specs,
                FindOptions<{entityName}> options,
                CancellationToken ct) =>
                {entityName}.WithContextAsync(context => context.Provider.FindAllAsync(specs, options, ct));

            protected override Task<ResultPaged<{entityName}>> FindAllPagedInternal(
                IEnumerable<ISpecification<{entityName}>> specs,
                FindOptions<{entityName}> options,
                CancellationToken ct) =>
                {entityName}.WithContextAsync(context => context.Provider.FindAllPagedAsync(specs, options, ct));

            protected override Task<Result<{entityName}>> FindOneInternal(
                IEnumerable<ISpecification<{entityName}>> specs,
                FindOptions<{entityName}> options,
                CancellationToken ct) =>
                {entityName}.WithContextAsync(context => context.Provider.FindOneAsync(specs, options, ct));

            protected override Task<Result<bool>> ExistsInternal(
                IEnumerable<ISpecification<{entityName}>> specs,
                FindOptions<{entityName}> options,
                CancellationToken ct) =>
                {entityName}.WithContextAsync(context => context.Provider.ExistsAsync(specs, options, ct));

            protected override Task<Result<long>> CountInternal(
                IEnumerable<ISpecification<{entityName}>> specs,
                FindOptions<{entityName}> options,
                CancellationToken ct) =>
                {entityName}.WithContextAsync(context => context.Provider.CountAsync(specs, options, ct));

            protected override Task<Result<IEnumerable<TProjection>>> ProjectAllInternal<TProjection>(
                IEnumerable<ISpecification<{entityName}>> specs,
                Expression<Func<{entityName}, TProjection>> projection,
                FindOptions<{entityName}> options,
                CancellationToken ct) =>
                {entityName}.WithContextAsync(context => context.Provider.ProjectAllAsync(specs, projection, options, ct));

            protected override Task<ResultPaged<TProjection>> ProjectAllPagedInternal<TProjection>(
                IEnumerable<ISpecification<{entityName}>> specs,
                Expression<Func<{entityName}, TProjection>> projection,
                FindOptions<{entityName}> options,
                CancellationToken ct) =>
                {entityName}.WithContextAsync(context => context.Provider.ProjectAllPagedAsync(specs, projection, options, ct));
        }}
    }}
}}
");

        context.AddSource($"{entityName}.ActiveEntityQueryDsl.g.cs", sb.ToString());
    }
}
#pragma warning restore RS1042
#pragma warning restore RS1036
#pragma warning restore RS1035
#pragma warning restore RS1038

[Flags]
public enum ActiveEntityFeatures
{
    None = 0,
    Forwarders = 1 << 0,
    ConventionFinders = 1 << 1,
    Specifications = 1 << 2,
    QueryDsl = 1 << 3,
    All = ~0
}

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public sealed class ActiveEntityFeaturesAttribute(ActiveEntityFeatures features = ActiveEntityFeatures.All) : Attribute
{
    public ActiveEntityFeatures Features { get; } = features;
}

public interface IActiveEntityFeature
{
    ActiveEntityFeatures Features { get; }

    void Generate(SourceProductionContext context, Compilation compilation, INamedTypeSymbol entityType, ActiveEntityFeatures enabledFeatures, FeatureGenerationContext featureContext);
}

public class FeatureGenerationContext
{
    public FeatureGenerationContext(INamedTypeSymbol valueObjectSymbol, INamedTypeSymbol enumerationSymbol)
    {
        this.ValueObjectSymbol = valueObjectSymbol;
        this.EnumerationSymbol = enumerationSymbol;
    }

    public INamedTypeSymbol ValueObjectSymbol { get; }

    public INamedTypeSymbol EnumerationSymbol { get; }
}