// MIT-License
// Copyright BridgingIT GmbH - All Rights Reserved
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file at https://github.com/bridgingit/bitdevkit/license
namespace BridgingIT.DevKit.Domain;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
#pragma warning disable RS1036 // Specify analyzer banned API enforcement setting
#pragma warning disable RS1042 // Implementations of this interface are not allowed
#pragma warning disable RS1038 // Compiler extensions should be implemented in assemblies with compiler-provided references
[Generator]
public class DomainEventConstructorGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver to find classes deriving from DomainEventBase
        context.RegisterForSyntaxNotifications(() => new DomainEventSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not DomainEventSyntaxReceiver receiver)
            return;

        var domainEventBaseType = context.Compilation.GetTypeByMetadataName("BridgingIT.DevKit.Domain.DomainEventBase");
        if (domainEventBaseType == null)
        {
            return;
        }

        foreach (var candidate in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(candidate.SyntaxTree);
            var symbol = model.GetDeclaredSymbol(candidate) as INamedTypeSymbol;
            if (symbol == null || !symbol.BaseType?.Equals(domainEventBaseType, SymbolEqualityComparer.Default) == true)
            {
                continue;
            }

            // Check if the class is already partial
            var isPartial = candidate.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
            if (!isPartial)
            {
                // Optionally log a warning or throw an error
                //context.ReportDiagnostic(Diagnostic.Create(
                //    new DiagnosticDescriptor(
                //        "DECG001",
                //        "Partial Keyword Missing",
                //        $"Class {symbol.Name} derives from DomainEventBase but is not marked as partial. Add 'partial' keyword to allow constructor generation.",
                //        "DomainEventConstructorGenerator",
                //        DiagnosticSeverity.Warning,
                //        isEnabledByDefault: true),
                //    candidate.GetLocation()));
                continue;
            }

            var hasParameterlessCtor = symbol.Constructors.Any(c => c.Parameters.Length == 0 && c.DeclaredAccessibility != Accessibility.Private);
            var hasPrivateParameterlessCtor = symbol.Constructors.Any(c => c.Parameters.Length == 0 && c.DeclaredAccessibility == Accessibility.Private);

            if (!hasParameterlessCtor && !hasPrivateParameterlessCtor)
            {
                var source = this.GenerateConstructorAddition(symbol);
                context.AddSource($"{symbol.Name}_Generated.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private string GenerateConstructorAddition(INamedTypeSymbol symbol)
    {
        var namespaceName = symbol.ContainingNamespace.ToDisplayString();
        var className = symbol.Name;

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine($"namespace {namespaceName};");
        builder.AppendLine();
        builder.AppendLine($"public partial class {className}");
        builder.AppendLine("{");
        builder.AppendLine($"    private {className}() : this(default) // Added for JSON deserialization");
        builder.AppendLine("    {");
        builder.AppendLine("    }");
        builder.AppendLine("}");

        return builder.ToString();
    }

    private class DomainEventSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                classDeclaration.BaseList?.Types.Any(b => b.Type is GenericNameSyntax || b.Type.ToString().Contains("DomainEventBase")) == true)
            {
                this.CandidateClasses.Add(classDeclaration);
            }
        }
    }
}
#pragma warning restore RS1042
#pragma warning restore RS1036
#pragma warning restore RS1035
#pragma warning restore RS1038