// MIT-License
// Copyright BridgingIT GmbH - All Rights Reserved
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file at https://github.com/bridgingit/bitdevkit/license
namespace BridgingIT.DevKit.Domain;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
#pragma warning disable RS1036 // Specify analyzer banned API enforcement setting
#pragma warning disable RS1042 // Implementations of this interface are not allowed
#pragma warning disable RS1038 // Compiler extensions should be implemented in assemblies with compiler-provided references
[Generator]
public class DomainEventConstructorGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new DomainEventSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not DomainEventSyntaxReceiver receiver)
        {
            return;
        }

        var domainEventBaseType = context.Compilation.GetTypeByMetadataName("BridgingIT.DevKit.Domain.DomainEventBase");
        if (domainEventBaseType == null)
        {
            return;
        }

        foreach (var candidate in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(candidate.SyntaxTree);
            var symbol = model.GetDeclaredSymbol(candidate) as INamedTypeSymbol;
            if (symbol == null ||
                !symbol.BaseType?.Equals(domainEventBaseType, SymbolEqualityComparer.Default) == true)
            {
                continue;
            }

            var isPartial = candidate.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
            if (!isPartial)
            {
                continue;
            }

            var hasParameterlessCtor = symbol.Constructors.Any(
                c => c.Parameters.Length == 0 && c.DeclaredAccessibility != Accessibility.Private);
            var hasPrivateParameterlessCtor = symbol.Constructors.Any(
                c => c.Parameters.Length == 0 && c.DeclaredAccessibility == Accessibility.Private);

            if (!hasParameterlessCtor && !hasPrivateParameterlessCtor)
            {
                var source = this.GenerateConstructorAddition(symbol);
                context.AddSource($"{symbol.Name}_Generated.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private string GenerateConstructorAddition(INamedTypeSymbol symbol)
    {
        var namespaceName = symbol.ContainingNamespace.ToDisplayString();
        var className = symbol.Name;

        // Choose the constructor we intend to chain to.
        // Strategy: pick the instance constructor with the most parameters
        // that is not private. If none found, fall back to first (if any).
        var targetCtor = symbol
            .Constructors
            .Where(c => !c.IsStatic)
            .OrderByDescending(c => c.Parameters.Length)
            .ThenBy(c => c.DeclaredAccessibility == Accessibility.Private) // prefer non-private
            .FirstOrDefault();

        // Build ", default, default, ..." argument list
        var argList = BuildDefaultArgumentList(targetCtor?.Parameters.Length ?? 0);

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine($"namespace {namespaceName};");
        builder.AppendLine();
        builder.AppendLine($"public partial class {className}");
        builder.AppendLine("{");
        builder.AppendLine(
            $"    private {className}() : this({argList}) // Added for JSON deserialization");
        builder.AppendLine("    {");
        builder.AppendLine("    }");
        builder.AppendLine("}");

        return builder.ToString();
    }

    private static string BuildDefaultArgumentList(int count)
    {
        if (count <= 0)
        {
            return string.Empty;
        }
        // Emit 'default' repeated count times, comma-separated
        return string.Join(", ", Enumerable.Repeat("default", count));
    }

    private class DomainEventSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                classDeclaration.BaseList?.Types.Any(
                    b => b.Type is GenericNameSyntax ||
                         b.Type.ToString().Contains("DomainEventBase")) == true)
            {
                this.CandidateClasses.Add(classDeclaration);
            }
        }
    }
}
#pragma warning restore RS1042
#pragma warning restore RS1036
#pragma warning restore RS1035
#pragma warning restore RS1038