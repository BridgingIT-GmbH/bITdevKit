// MIT-License
// Copyright BridgingIT GmbH - All Rights Reserved
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file at https://github.com/bridgingit/bitdevkit/license

namespace BridgingIT.DevKit.Domain;

using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
#pragma warning disable RS1036 // Specify analyzer banned API enforcement setting
#pragma warning disable RS1042 // Implementations of this interface are not allowed
#pragma warning disable RS1038 // Compiler extensions should be implemented in assemblies with compiler-provided references
[Generator]
public class EnumerationPartialGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver to find classes deriving from Enumeration
        context.RegisterForSyntaxNotifications(() => new EnumerationSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not EnumerationSyntaxReceiver receiver)
        {
            return;
        }

        var enumerationType = context.Compilation.GetTypeByMetadataName("BridgingIT.DevKit.Common.Enumeration");
        //var genericEnumerationType = context.Compilation.GetTypeByMetadataName("BridgingIT.DevKit.Common.Enumeration`2");
        if (enumerationType == null/* && genericEnumerationType == null*/)
        {
            return;
        }

        foreach (var candidate in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(candidate.SyntaxTree);
            var symbol = model.GetDeclaredSymbol(candidate) as INamedTypeSymbol;
            if (symbol == null)
            {
                continue;
            }

            // Check if the class derives from Enumeration or Enumeration<TId, TValue>
            var isEnumeration = symbol.BaseType?.Equals(enumerationType, SymbolEqualityComparer.Default) == true; //||
                                                                                                                  //symbol.BaseType?.ConstructedFrom.Equals(genericEnumerationType, SymbolEqualityComparer.Default) == true;
            if (!isEnumeration)
            {
                continue;
            }

            // Check if the class is already partial
            var isPartial = candidate.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
            if (!isPartial)
            {
                //context.ReportDiagnostic(Diagnostic.Create(
                //    new DiagnosticDescriptor(
                //        "EPG001",
                //        "Partial Keyword Missing",
                //        $"Class {symbol.Name} derives from Enumeration but is not marked as partial. Add 'partial' keyword to allow partial class generation.",
                //        "EnumerationPartialGenerator",
                //        DiagnosticSeverity.Warning,
                //        isEnabledByDefault: true),
                //    candidate.GetLocation()));
                continue;
            }

            var source = this.GenerateEnumerationPartial(symbol);
            context.AddSource($"{symbol.Name}_PartialGenerated.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private string GenerateEnumerationPartial(INamedTypeSymbol symbol)
    {
        var namespaceName = symbol.ContainingNamespace.ToDisplayString();
        var className = symbol.Name;

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine($"namespace {namespaceName};");
        builder.AppendLine();
        builder.AppendLine($"public partial class {className}");
        builder.AppendLine("{");

        // Generate parameterized constructor based on properties
        var localProperties = symbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility != Accessibility.Private && !p.IsStatic) // Exclude private and static properties
            .OrderBy(p => p.Name != "Id" && p.Name != "Value" ? 1 : 0) // Prioritize Id and Value first
            .ThenBy(p => p.DeclaringSyntaxReferences.First().GetSyntax().GetLocation().SourceSpan.Start); // Order by declaration order

        var paramList = new List<string> { "int id", "string value" }; // Start with Id and Value
        var assignmentList = new List<string>();
        foreach (var prop in localProperties)
        {
            var paramType = prop.Type.ToDisplayString();
            var paramName = char.ToLower(prop.Name[0]) + prop.Name.Substring(1); // CamelCase parameter name
            var isNullable = prop.NullableAnnotation == NullableAnnotation.Annotated || prop.Type.IsReferenceType;
            paramList.Add($"{paramType}{(isNullable ? "?" : "")} {paramName} = {(isNullable ? "null" : "default")}");
            assignmentList.Add($"this.{prop.Name} = {paramName};");
        }

        builder.AppendLine($"    private {className}({string.Join(", ", paramList)}) : base(id, value)");
        builder.AppendLine("    {");
        builder.AppendLine(string.Join("\n        ", assignmentList));
        builder.AppendLine("    }");
        builder.AppendLine();

        // Generate private parameterless constructor for JSON deserialization
        builder.AppendLine($"    private {className}() // Added for JSON deserialization");
        builder.AppendLine("    {");
        builder.AppendLine("    }");
        builder.AppendLine();

        // Generate GetAll method
        builder.AppendLine("    /// <summary>");
        builder.AppendLine($"    /// Retrieves all defined <see cref=\"{className}\"/> instances.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine($"    /// <returns>All defined <see cref=\"{className}\"/> instances.</returns>");
        builder.AppendLine($"    public static IEnumerable<{className}> GetAll()");
        builder.AppendLine("    {");
        builder.AppendLine($"        return GetAll<{className}>();");
        builder.AppendLine("    }");
        builder.AppendLine();

        // Generate GetById method
        builder.AppendLine("    /// <summary>");
        builder.AppendLine($"    /// Retrieves a <see cref=\"{className}\"/> instance by its unique identifier.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    /// <param name=\"id\">The unique identifier of the status.</param>");
        builder.AppendLine($"    /// <returns>The <see cref=\"{className}\"/> instance associated with the given <paramref name=\"id\"/>.");
        builder.AppendLine("    /// </returns>");
        builder.AppendLine("    /// <exception cref=\"ArgumentException\">");
        builder.AppendLine($"    /// Thrown if no <see cref=\"{className}\"/> instance exists with the specified <paramref name=\"id\"/>.");
        builder.AppendLine("    /// </exception>");
        builder.AppendLine($"    public static {className} GetById(int id)");
        builder.AppendLine("    {");
        builder.AppendLine($"        return GetAll<{className}>()");
        builder.AppendLine($"            .FirstOrDefault(e => e.Id == id) ?? throw new ArgumentException($\"No {className} exists with Id {{id}}\", nameof(id));");
        builder.AppendLine("    }");
        builder.AppendLine();

        // Generate implicit operator
        builder.AppendLine("    /// <summary>");
        builder.AppendLine($"    /// Implicitly converts an <see cref=\"int\"/> identifier into a corresponding");
        builder.AppendLine($"    /// <see cref=\"{className}\"/> if one exists.");
        builder.AppendLine("    /// </summary>");
        builder.AppendLine("    /// <param name=\"id\">The identifier of the customer status.</param>");
        builder.AppendLine("    /// <exception cref=\"ArgumentException\">");
        builder.AppendLine($"    /// Thrown if no customer status is defined with the specified <paramref name=\"id\"/>.");
        builder.AppendLine("    /// </exception>");
        builder.AppendLine($"    /// <returns>The <see cref=\"{className}\"/> instance associated with the given <paramref name=\"id\"/>.");
        builder.AppendLine("    /// </returns>");
        builder.AppendLine($"    public static implicit operator {className}(int id)");
        builder.AppendLine("    {");
        builder.AppendLine($"        return GetAll<{className}>().FirstOrDefault(e => e.Id == id)");
        builder.AppendLine($"            ?? throw new ArgumentException($\"No {className} exists with Id {{id}}\", nameof(id));");
        builder.AppendLine("    }");
        builder.AppendLine("}");
        return builder.ToString();
    }

    private class EnumerationSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                classDeclaration.BaseList?.Types.Any(b => b.Type is GenericNameSyntax gns && gns.Identifier.Text == "Enumeration" ||
                                                        b.Type.ToString().Contains("Enumeration")) == true)
            {
                this.CandidateClasses.Add(classDeclaration);
            }
        }
    }
}
#pragma warning restore RS1042
#pragma warning restore RS1036
#pragma warning restore RS1035
#pragma warning restore RS1038